<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_beta_zombie_idle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize Variables

grav = 0;
hsp = 0;
vsp = 0;
freeze = 1
sprite_idle = spr_beta_zombie_idle;
sprite_walk_left = spr_beta_zombie_walk_left;
sprite_walk_right = spr_beta_zombie_walk_right;
image_speed = 0.08;
arena = ar_beta_zombie //Which room will the battle take place, this may become a script to decide where to fight

//If movement is not allowed after a certain frame, put in freeze_frame. Otherwise put 1000
freeze_frame = 2 

///Depth
depth = -1101;

//states
aggro_state = aggro_states.patrol;
patrol_dist = p_dist.d_mid;

//state variables
patrol_speed = 1;
patrol_dist_max = 200;
patrol_dist_min = -patrol_dist_max;
patrol_dist_mid = 0;
cur_patrol_dist = 0;
chase_speed = 2;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sprite Control

if ( hsp == 0 )
{
    sprite_index = sprite_idle;
}

if ( hsp &gt; 0 )
{
    sprite_index = sprite_walk_right;
}

if ( hsp &lt; 0 )
{
    sprite_index = sprite_walk_left;
}


//This sprite has an unusual animation that would cause movement to stop. 
if ( image_index &gt;= freeze_frame ) 
{
    freeze = 0;
}
else
{
    freeze = 1;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Enter Arena

//If the enemy touches the battle_block created by obj_player
if (place_meeting(x,y, obj_battle_block))
{
    //If there is no room_transition
    if(!instance_exists(obj_room_transition))
    {
        //All these if statements decide if the fight is Fair, Preemptive, or Enemy Strikes First
        if (( sign(obj_player.move) + sign(object_index.hsp) == 0 ))
        {
           fade_color = c_black; 
        }        
        if ((obj_battle_block.x &lt; object_index.x) &amp;&amp; ( sign(obj_player.move) + sign(object_index.hsp) == 2 ))
        {
           fade_color = c_green; 
        }        
        if ((obj_battle_block.x &lt; object_index.x) &amp;&amp; ( sign(obj_player.move) + sign(object_index.hsp) &lt;= -1 ))
        {
           fade_color = c_red; 
        }        
        if ((obj_battle_block.x &gt; object_index.x) &amp;&amp; ( sign(obj_player.move) + sign(object_index.hsp) == 2 ))
        {
           fade_color = c_red; 
        }        
        if ((obj_battle_block.x &gt; object_index.x) &amp;&amp; ( sign(obj_player.move) + sign(object_index.hsp) &lt;= -1 ))
        {
           fade_color = c_green; 
        }        
        //This creates the transition. The transition will actually do the "goto room" move, but the room is decided as a variable on the enemy marked "Arena"
        var tempRoomFade;
        tempRoomFade = instance_create(x,y,obj_room_transition);
        //I don't completely understand the other.arena thing, but it works right now, so... we'll see if it breaks stuff later.
        tempRoomFade.tempTarget = other.arena
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Aggro States
//*CURRENTLY MUST BE MADE FOR EACH PLAYABLE CHARACTER, AND EACH ENEMY TYPE*
//Zombie Aggro
switch (aggro_state)
{
    case aggro_states.patrol:
    {
        script_execute(scr_patrol_timer)
        vsp = 0;
        if (distance_to_object(obj_player) &lt; 200) 
        {
            aggro_state = aggro_states.chase;
        }
        break;
    }
    case aggro_states.chase:
    {
        dir = sign(obj_player.x - x);
        hsp = dir * chase_speed;
        vsp = sign(obj_player.y-y);
        if (distance_to_object(obj_player) &gt; 300) 
        {
            aggro_state = aggro_states.patrol
        }  
        break;
    }
}

if (place_meeting(x + hsp, y, obj_wall_objects))
{
    while(!place_meeting(x + sign(hsp), y, obj_wall_objects))
    {
        x += sign(hsp);        
    }
    hsp=0;
}


x += ( ( hsp * freeze ) + move_all )
y += ( vsp )
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
